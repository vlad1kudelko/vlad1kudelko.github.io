---
title: "AI-агенты на Go: почему ADK — это не просто очередной обертка над LLM"
description: "Разбор нового фреймворка Agent Development Kit от Google. Как писать надежных ИИ-агентов на Go, используя принципы Software Engineering."
heroImage: "../../../../assets/imgs/2025/11/12-google-adk-go.webp"
pubDate: "2025-11-12"
github: "https://github.com/google/adk-go"
---

# От скриптов к системам: Почему ваш следующий AI-агент должен быть написан на Go с помощью ADK.

Большинство современных инструментов для создания AI-агентов родились в экосистеме Python. Это отлично для прототипирования и Data Science, но когда дело доходит до продакшена, высокой нагрузки и облачной инфраструктуры, разработчики часто смотрят в сторону Go.

Google представил **Agent Development Kit (ADK) для Go** — инструмент, который переносит лучшие практики разработки ПО в мир LLM-агентов.

## В чем проблема?

Создание агента сегодня часто напоминает «программирование на естественном языке». Вы пишете длинный системный промпт, надеетесь, что модель правильно вызовет функцию (tool calling), и пытаетесь склеить это всё набором скриптов.

Проблемы начинаются быстро:

* **Сложность отладки:** Трудно понять, на каком этапе агент «свернул не туда».
* **Тестируемость:** Как гарантировать, что изменение в одном инструменте не сломает логику всего агента?
* **Производительность:** В многоагентных системах конкурентность и скорость работы критичны.

**ADK решает это через code-first подход.** Вместо того чтобы полагаться только на магию промптов, вы описываете логику, инструменты и связи между агентами как структурированный код на Go.

## Архитектура и стек

ADK спроектирован как модульный конструктор. Хотя он оптимизирован для работы с Gemini, архитектура остается **model-agnostic** и **deployment-agnostic**.

## Почему Go?

Выбор языка здесь не случаен. Для системных интеграций и облачных решений (Cloud Native) Go идеален:

1. **Строгая типизация:** Меньше ошибок при передаче данных между инструментами и моделью.
2. **Конкурентность (Goroutines):** Незаменима, когда один агент должен параллельно опрашивать несколько API или когда вы запускаете целый «рой» агентов.
3. **Бинарная чистота:** Легкая контейнеризация и деплой (например, в Cloud Run) без ада зависимостей.

## Ключевые компоненты

* **Agents:** Логические единицы, обладающие ролью и набором инструментов.
* **Tools:** Обычные функции Go, которые агент может вызывать для взаимодействия с внешним миром.
* **Orchestration:** Механизмы управления потоком задач между несколькими агентами.

## Быстрый старт

Развернуть проект на Go проще, чем настроить виртуальное окружение в Python.

1. **Инициализируйте проект:**

```bash
go mod init my-agent-app
```

2. **Установите ADK:**

```bash
go get google.golang.org/adk
```

3. **Настройте доступ к LLM:**

Вам понадобится API ключ (например, от Google AI Studio для Gemini).

```bash
export GOOGLE_API_KEY="your_api_key_here"
```

## Примеры использования: Создаем агента-помощника

Допустим, нам нужен агент, который умеет проверять погоду и отправлять уведомления. В ADK определение инструмента (Tool) выглядит максимально естественно:

```go
package main

import (
	"context"
	"fmt"
	"google.golang.org/adk"
	"google.golang.org/adk/model/gemini"
)

// Обычная функция на Go — это и есть наш Tool
func GetWeather(ctx context.Context, city string) (string, error) {
	// Здесь могла бы быть логика обращения к API
	return fmt.Sprintf("В городе %s сейчас солнечно, +25°C", city), nil
}

func main() {
	ctx := context.Background()

	// Инициализируем модель (Gemini)
	m, _ := gemini.NewModel(ctx, "gemini-1.5-flash")

	// Создаем агента и регистрируем инструмент
	agent := adk.NewAgent(m, "Ты полезный ассистент.")
	agent.RegisterTool(GetWeather)

	// Задаем вопрос
	response, _ := agent.Chat(ctx, "Какая сейчас погода в Лиссабоне?")
	fmt.Println(response)
}
```

Этот подход позволяет вам использовать стандартные юнит-тесты Go для проверки `GetWeather`, а ADK берет на себя всю грязную работу по генерации JSON-схемы для LLM и обработке вызовов.

## Будущее за типизированными агентами

ADK для Go — это шаг в сторону зрелости AI-разработки. Проект активно развивается: в планах расширение экосистемы готовых инструментов (Connectors), более глубокая интеграция с мониторингом и улучшенные механизмы оценки (evaluation).
